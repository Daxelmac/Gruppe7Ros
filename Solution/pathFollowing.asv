function [reachedGoal] = DXPathfollowing(start, stop, robotWidth, resolution, angle)

% Substriptions
laserSub = rossubscriber('/scan');
odomSub = rossubscriber('/odom');

% Publishers
[publisher,msg] = rospublisher('/mobile_base/commands/reset_odometry','std_msgs/Empty');
send(publisher,msg); % reseting odometery

[velocityPub,velocityMsg] = rospublisher('/mobile_base/commands/velocity','geometry_msgs/Twist');
turtlebot = rospublisher('/mobile_base/commands/velocity');

velocityMsg = rosmessage(turtlebot);

%% Settings
goalRadius = 1; 
startPosition = start;
endPosition = stop;
pixelResolution = resolution;
robotAngle = angle;
margin = 0.3;

%% Create Occupancy Map from Shannon map
mapColor = imread('shannon.png');

mapBW = rgb2gray(mapColor);

meanVal = mean(mapBW(:));

imageBinary = mapBW < meanVal;

imageBinaryFlipped = flipud(imageBinary);

se = ones(round(((robotWidth / 2) + margin) * pixelResolution));

imageBinaryDilatedFlipped = imdilate(imageBinaryFlipped,se);
figure(), imshow(imageBinaryDilatedFlipped);

map = robotics.BinaryOccupancyGrid(imageBinaryDilated, pixelResolution);
figur(), show(map)

%% Find Path
dx = DXform(imageBinaryDilatedFlipped);
dx.plan(endPosition);
path = dx.query(startPosition); 
path = path/map.Resolution;

distanceToDestination = norm(startPosition/map.Resolution - goalRadius);

%% Purepursuit controller
controller = controllerPurePursuit;

controller.Waypoints = path;

controller.DesiredLinearVelocity = 0.4;

controller.MaxAngularVelocity = 1;

controller.LookaheadDistance = 1;

%% VFH Controller for obstacle avoidance
vfh = setUpVFHController();
minRangeObstacleDetect = 0;
maxRangeObstacleDetect = 0.6;
angleIntervalThreshold = 0.15;

%% Setup Monte Carlo Localization
startPositionInMeters = startPosition/map.Resolution;

initPose = [startPosition(1), startPosition(2), robotAngle];

amcl = setupAMCL(map);

visualizationHelper = ExampleHelperAMCLVisualization(map);

%% Drive to destination

i=0;
while(distanceToDestination >= goalRadius)
    position = getPosition(odomSub, startPositionInMeters);
    scanMsg = receive(laserSub);
    scan = lidarScan(scanMsg);
    [estimatedPosition, i] = runAMCL(amcl, scan, position, i, visualizationHelper);
    
    isObstacle = checkForObstacle(scan, minRangeObstacleDetect, maxRangeObstacleDetect, angleIntervalThreshold);

    if(isObstacle)
        numberOfIterations = avoidObstacle(vfh, estimatedPosition(3), laserSub, robot, velMsg, odomSub, startInMeters, amcl,i, visualizationHelper);
        i = numberOfIterations;
    else
        % Pass new information to turtlebot.
        [linVel, angVel, targetDir] = controller(estimatedPosition); 
        velmsg.Linear.X = linVel; 
        velmsg.Angular.Z = angVel;
        send(robot, velmsg);
    end 
            
    distanceToGoal = norm(estimatedPosition(1:2) - goal/map.Resolution);  
end
